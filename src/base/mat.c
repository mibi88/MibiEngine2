/* A small OpenGL ES engine.
 * by Mibi88
 *
 * This software is licensed under the BSD-3-Clause license:
 *
 * Copyright 2025 Mibi88
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <mibiengine2/base/mat.h>

#include <string.h>

#include <math.h>

/*
 * Useful links:
 * https://en.wikipedia.org/wiki/Matrix_multiplication
 * https://en.wikipedia.org/wiki/Rotation_matrix
 * https://en.wikipedia.org/wiki/Transformation_matrix
 * https://www.geeksforgeeks.org/computer-graphics-3d-translation-transformatio
 * n/
 * https://songho.ca/opengl/gl_projectionmatrix.html
 * https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-ort
 * hographic-projection-matrix/opengl-perspective-projection-matrix.html
 * https://en.wikipedia.org/wiki/Transpose
 * https://en.wikipedia.org/wiki/Scaling_(geometry)#Matrix_representation
 * https://learn.microsoft.com/en-us/windows/win32/opengl/glortho
 */

/* 02/03/2025:
 * ge_mat4_identity works.
 * ge_mat4_mmul seems to be working fine.
 * ge_mat4_mvmul and mat4_vmmul are untested.
 * ge_mat4_rot3d seems to be working correctly.
 * ge_mat4_translate3d works.
 * ge_mat4_projection3d works, but made by tweaking a matrix made by reading
 *                   some stuff from the internet and looking at a projection
 *                   matrix generated by JOML in MibiFlightSimulator in
 *                   RenderDoc XD.
 * 10/03/2025:
 * ge_mat4_transpose seems to work.
 */

void ge_mat4_identity(GEMat4 *mat) {
    int x, y;
    for(y=0;y<4;y++){
        for(x=0;x<4;x++){
            mat->mat[y*4+x] = x == y;
        }
    }
}

void ge_mat4_mmul(GEMat4 *dest, GEMat4 *src1, GEMat4 *src2) {
    int x, y, i;
    for(y=0;y<4;y++){
        for(x=0;x<4;x++){
            dest->mat[y*4+x] = 0;
            for(i=0;i<4;i++){
                dest->mat[y*4+x] += src1->mat[i*4+x]*src2->mat[y*4+i];
            }
        }
    }
}

void ge_mat4_mvmul(GEVec4 *dest, GEMat4 *mat, GEVec4 *vec) {
    dest->x = mat->mat[0*4+0]*vec->x+mat->mat[0*4+1]*vec->y+
              mat->mat[0*4+2]*vec->z+mat->mat[0*4+3]*vec->w;
    dest->y = mat->mat[1*4+0]*vec->x+mat->mat[1*4+1]*vec->y+
              mat->mat[1*4+2]*vec->z+mat->mat[1*4+3]*vec->w;
    dest->z = mat->mat[2*4+0]*vec->x+mat->mat[2*4+1]*vec->y+
              mat->mat[2*4+2]*vec->z+mat->mat[2*4+3]*vec->w;
    dest->w = mat->mat[3*4+0]*vec->x+mat->mat[3*4+1]*vec->y+
              mat->mat[3*4+2]*vec->z+mat->mat[3*4+3]*vec->w;
}

void ge_mat4_vmmul(GEVec4 *dest, GEVec4 *vec, GEMat4 *mat) {
    dest->x = vec->x*mat->mat[0*4+0]+vec->y*mat->mat[1*4+0]+
              vec->z*mat->mat[2*4+0]+vec->w*mat->mat[3*4+0];
    dest->y = vec->x*mat->mat[0*4+1]+vec->y*mat->mat[1*4+1]+
              vec->z*mat->mat[2*4+1]+vec->w*mat->mat[3*4+1];
    dest->z = vec->x*mat->mat[0*4+2]+vec->y*mat->mat[1*4+2]+
              vec->z*mat->mat[2*4+2]+vec->w*mat->mat[3*4+2];
    dest->w = vec->x*mat->mat[0*4+3]+vec->y*mat->mat[1*4+3]+
              vec->z*mat->mat[2*4+3]+vec->w*mat->mat[3*4+3];
}

void ge_mat4_transpose(GEMat4 *dest, GEMat4 *src) {
    int x, y;
    for(y=0;y<4;y++){
        for(x=0;x<4;x++){
            dest->mat[y*4+x] = src->mat[x*4+y];
        }
    }
}

void ge_mat4_inverse(GEMat4 *dest, GEMat4 *src) {
    /* TODO */
    (void)dest;
    (void)src;
}

void ge_mat4_rot3d(GEMat4 *mat, GEAxis axis, float angle) {
    switch(axis){
        case GE_A_X:
            mat->mat[0*4+0] = 1;
            mat->mat[0*4+1] = 0;
            mat->mat[0*4+2] = 0;
            mat->mat[0*4+3] = 0;
            
            mat->mat[1*4+0] = 0;
            mat->mat[1*4+1] = cos(angle/180*GE_MAT_PI);
            mat->mat[1*4+2] = -sin(angle/180*GE_MAT_PI);
            mat->mat[1*4+3] = 0;
            
            mat->mat[2*4+0] = 0;
            mat->mat[2*4+1] = sin(angle/180*GE_MAT_PI);
            mat->mat[2*4+2] = cos(angle/180*GE_MAT_PI);
            mat->mat[2*4+3] = 0;
            
            mat->mat[3*4+0] = 0;
            mat->mat[3*4+1] = 0;
            mat->mat[3*4+2] = 0;
            mat->mat[3*4+3] = 1;
            break;
        case GE_A_Y:
            mat->mat[0*4+0] = cos(angle/180*GE_MAT_PI);
            mat->mat[0*4+1] = 0;
            mat->mat[0*4+2] = sin(angle/180*GE_MAT_PI);
            mat->mat[0*4+3] = 0;
            
            mat->mat[1*4+0] = 0;
            mat->mat[1*4+1] = 1;
            mat->mat[1*4+2] = 0;
            mat->mat[1*4+3] = 0;
            
            mat->mat[2*4+0] = -sin(angle/180*GE_MAT_PI);
            mat->mat[2*4+1] = 0;
            mat->mat[2*4+2] = cos(angle/180*GE_MAT_PI);
            mat->mat[2*4+3] = 0;
            
            mat->mat[3*4+0] = 0;
            mat->mat[3*4+1] = 0;
            mat->mat[3*4+2] = 0;
            mat->mat[3*4+3] = 1;
            break;
        case GE_A_Z:
            mat->mat[0*4+0] = cos(angle/180*GE_MAT_PI);
            mat->mat[0*4+1] = -sin(angle/180*GE_MAT_PI);
            mat->mat[0*4+2] = 0;
            mat->mat[0*4+3] = 0;
            
            mat->mat[1*4+0] = sin(angle/180*GE_MAT_PI);
            mat->mat[1*4+1] = cos(angle/180*GE_MAT_PI);
            mat->mat[1*4+2] = 0;
            mat->mat[1*4+3] = 0;
            
            mat->mat[2*4+0] = 0;
            mat->mat[2*4+1] = 0;
            mat->mat[2*4+2] = 1;
            mat->mat[2*4+3] = 0;
            
            mat->mat[3*4+0] = 0;
            mat->mat[3*4+1] = 0;
            mat->mat[3*4+2] = 0;
            mat->mat[3*4+3] = 1;
            break;
        default:
            break;
    }
}

void ge_mat4_translate3d(GEMat4 *mat, float x, float y, float z) {
    mat->mat[0*4+0] = 1;
    mat->mat[0*4+1] = 0;
    mat->mat[0*4+2] = 0;
    mat->mat[0*4+3] = 0;
    
    mat->mat[1*4+0] = 0;
    mat->mat[1*4+1] = 1;
    mat->mat[1*4+2] = 0;
    mat->mat[1*4+3] = 0;
    
    mat->mat[2*4+0] = 0;
    mat->mat[2*4+1] = 0;
    mat->mat[2*4+2] = 1;
    mat->mat[2*4+3] = 0;
    
    mat->mat[3*4+0] = x;
    mat->mat[3*4+1] = y;
    mat->mat[3*4+2] = z;
    mat->mat[3*4+3] = 1;
}

void ge_mat4_scale3d(GEMat4 *mat, float x, float y, float z) {
    mat->mat[0*4+0] = x;
    mat->mat[0*4+1] = 0;
    mat->mat[0*4+2] = 0;
    mat->mat[0*4+3] = 0;
    
    mat->mat[1*4+0] = 0;
    mat->mat[1*4+1] = y;
    mat->mat[1*4+2] = 0;
    mat->mat[1*4+3] = 0;
    
    mat->mat[2*4+0] = 0;
    mat->mat[2*4+1] = 0;
    mat->mat[2*4+2] = z;
    mat->mat[2*4+3] = 0;
    
    mat->mat[3*4+0] = 0;
    mat->mat[3*4+1] = 0;
    mat->mat[3*4+2] = 0;
    mat->mat[3*4+3] = 1;
}

void ge_mat4_projection3d(GEMat4 *mat, float fov, float aspect_ratio,
                          float far, float near) {
    float f = 1/tan(fov/180*GE_MAT_PI/2);
    mat->mat[0*4+0] = f/aspect_ratio;
    mat->mat[0*4+1] = 0;
    mat->mat[0*4+2] = 0;
    mat->mat[0*4+3] = 0;
    
    mat->mat[1*4+0] = 0;
    mat->mat[1*4+1] = f;
    mat->mat[1*4+2] = 0;
    mat->mat[1*4+3] = 0;
    
    mat->mat[2*4+0] = 0;
    mat->mat[2*4+1] = 0;
    mat->mat[2*4+2] = -(far+near)/(far-near);
    mat->mat[2*4+3] = -1;
    
    mat->mat[3*4+0] = 0;
    mat->mat[3*4+1] = 0;
    mat->mat[3*4+2] = (2*far*near)/(near-far);
    mat->mat[3*4+3] = 0;
}

void ge_mat4_ortho3d(GEMat4 *mat, float left, float top, float right,
                     float bottom, float far, float near) {
    mat->mat[0*4+0] = 2/(left-right);
    mat->mat[0*4+1] = 0;
    mat->mat[0*4+2] = 0;
    mat->mat[0*4+3] = 0;
    
    mat->mat[1*4+0] = 0;
    mat->mat[1*4+1] = 2/(bottom-top);
    mat->mat[1*4+2] = 0;
    mat->mat[1*4+3] = 0;
    
    mat->mat[2*4+0] = 0;
    mat->mat[2*4+1] = 0;
    mat->mat[2*4+2] = -2/(far-near);
    mat->mat[2*4+3] = 0;
    
    mat->mat[3*4+0] = (left+right)/(left-right);
    mat->mat[3*4+1] = (bottom+top)/(bottom-top);
    mat->mat[3*4+2] = (far+near)/(far-near);
    mat->mat[3*4+3] = 1;
}

void ge_mat3_mat4(GEMat3 *mat3, GEMat4 *mat4) {
    memcpy(mat3->mat+0, mat4->mat+0, 3*sizeof(float));
    memcpy(mat3->mat+3, mat4->mat+4, 3*sizeof(float));
    memcpy(mat3->mat+6, mat4->mat+8, 3*sizeof(float));
}

